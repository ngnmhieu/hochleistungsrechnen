1. Kompilieren
"""""""""""""""""""""""""""
Das Programm ist mit folgenden Flags kompiliert: -pg -std=c11 -pedantic -Wall -Wextra

2. Profiling mit gprof:
"""""""""""""""""""""""""""
gprof zeigt eine Liste von den aufgerufenen Funktionen zusammen mit Informationen bzgl. der Laufzeit wie die Laufzeit der Funktion, kumulierte Laufzeit, Anzahl von Aufrufe, ... Die Liste wird nach Laufzeit sortiert. Darueber hinaus stellt gprof auch diese Informationen nochmal in einem Aufrufhierachie, mit der man festellen kann, welche Funktion von welcher Funktion aufgerufen wird.

Das Programm verbringt die meiste Zeit (94,64%) in der `calculate` Funktion, die nur einmal aufgerufen wird. Der Rest der Zeit verbringt das Programm in `getResiduum`, die aber ca. 2,7 Millionen mal aufgerufen wird.

3. Profiling mit perf:
""""""""""""""""""""""""""""
TODO

4. Optimierung des Programms
""""""""""""""""""""""""""""
Aus diesem Ergebnis des Profilings ist offensichlicht `calculate` zu optimieren und ggf. `getResiduum`.

Die Schleifen in der `calculate` Funktion werden so konstruiert, dass die Matrix-Elementen spaltenweise zugeriffen werden, d.h. der Code der inneren Schleife geht die Elementen in einer Spalten durch. Da Arrays in C zeilenweise im Hauptspeicher gespeichert werden, der Cache wird besser ausgenutzt (mehr Cache-Hit), wenn auf die Elementen auch zeilenweise zugegriffen wird.

Erste Optimierung: Die For-Schleife mit `i` und `j` austauschen.

Zweite Optimierung: aktiviert Optimierung des Compilers mit dem `-O3` Flag.

Ergebnis: das Programm läuft in ca. 12 Sekunden, viel schneller als das originale Programm, das in ca. 3 Minuten läuft.
